## Constructors

A **constructor** is a special member function that is automatically called when an object of a class is created. Its primary purpose is to initialize the object's members. A constructor has the same name as the class and does not have a return type, not even `void`.

### Key Characteristics:

  * **Automatic Invocation:** A constructor is called automatically when an object is created.
  * **No Return Type:** Constructors cannot return a value.
  * **Overloading:** You can have multiple constructors with different parameters (constructor overloading).
  * **Initialization:** They are used to set initial values for an object's data members.

There are three main types of constructors:

1.  **Default Constructor:** Takes no arguments. It's automatically generated by the compiler if you don't define any other constructors.
2.  **Parameterized Constructor:** Takes one or more arguments to initialize the object with specific values.
3.  **Copy Constructor:** Used to create a new object as a copy of an existing object.

### Code Example: Constructors

```cpp
#include <iostream>
#include <string>

class Student {
public:
    int studentID;
    std::string studentName;

    // 1. Default Constructor
    // Called when an object is created without any arguments.
    Student() {
        studentID = 0;
        studentName = "N/A";
        std::cout << "Default constructor called. Object initialized to default values." << std::endl;
    }

    // 2. Parameterized Constructor
    // Called when an object is created with arguments.
    // It initializes the object with the provided values.
    Student(int id, std::string name) {
        studentID = id;
        studentName = name;
        std::cout << "Parameterized constructor called. Student ID: " << studentID
                  << ", Name: " << studentName << std::endl;
    }

    // A simple member function to display details.
    void display() {
        std::cout << "Student ID: " << studentID << ", Name: " << studentName << std::endl;
    }
};

int main() {
    // Using the default constructor.
    Student s1;

    std::cout << "---------------------------------" << std::endl;

    // Using the parameterized constructor.
    Student s2(101, "Alice");

    std::cout << "---------------------------------" << std::endl;

    // The display function shows the initialized values.
    s1.display();
    s2.display();

    return 0;
}
```

-----

## Destructors

A **destructor** is a special member function that is automatically called when an object is about to be destroyed or goes out of scope. Its purpose is to perform cleanup, such as freeing memory allocated by the constructor or other member functions. A destructor has the same name as the class, preceded by a tilde (`~`), and does not take any arguments or have a return type.

### Key Characteristics:

  * **Automatic Invocation:** A destructor is called automatically when an object's lifetime ends (e.g., when a function returns or a block ends).
  * **No Return Type:** Destructors cannot return a value.
  * **No Parameters:** A destructor does not take any arguments, and therefore cannot be overloaded.
  * **Cleanup:** It's used to release resources (like dynamically allocated memory, file handles, etc.).

There can be only one destructor per class.

### Code Example: Destructors

This example demonstrates a destructor's role in memory management.

```cpp
#include <iostream>

class DynamicArray {
private:
    int* data;
    int size;

public:
    // Constructor: Allocates dynamic memory for the array.
    DynamicArray(int s) {
        size = s;
        data = new int[size]; // Dynamically allocating memory.
        std::cout << "Constructor called for DynamicArray of size " << size << ". Memory allocated." << std::endl;
    }

    // Destructor: Frees the dynamically allocated memory.
    // This is crucial to prevent memory leaks.
    ~DynamicArray() {
        delete[] data; // Deallocating the memory.
        std::cout << "Destructor called. Memory for the array has been freed." << std::endl;
    }
    
    // Member function to set a value.
    void setValue(int index, int value) {
        if (index >= 0 && index < size) {
            data[index] = value;
        }
    }

    // Member function to get a value.
    int getValue(int index) {
        if (index >= 0 && index < size) {
            return data[index];
        }
        return -1; // Or handle error appropriately.
    }
};

void createAndDestroy() {
    std::cout << "Entering createAndDestroy function." << std::endl;

    // An object of DynamicArray is created. The constructor is called.
    DynamicArray myArray(5);

    // Use the object...
    myArray.setValue(0, 100);
    std::cout << "Value at index 0 is: " << myArray.getValue(0) << std::endl;

    std::cout << "Exiting createAndDestroy function. Destructor will be called." << std::endl;
} // 'myArray' goes out of scope here, and the destructor is automatically called.

int main() {
    std::cout << "In main function, before calling createAndDestroy()." << std::endl;
    
    createAndDestroy();

    std::cout << "In main function, after calling createAndDestroy()." << std::endl;
    
    return 0;
}
```







A **parameterized constructor** is a constructor that accepts one or more arguments. It's used to initialize an object with user-provided values at the time of its creation, rather than using default values. This allows for more flexible and meaningful object initialization.

-----

### Key Details and Usage

  * **Purpose:** To initialize an object's data members with specific values passed during object creation.
  * **Syntax:** It follows the same naming convention as a default constructor (same name as the class) but includes a parameter list.
  * **Overloading:** You can have multiple parameterized constructors, as long as they have different parameter types or numbers of parameters (constructor overloading).
  * **Default vs. Parameterized:** If you define **any** constructor (default or parameterized), the compiler will **not** automatically provide a default constructor. You must explicitly define a default constructor if you still need one.

-----

### Code Example with Detailed Explanation

This C++ code demonstrates how to define and use parameterized constructors in a class. The example includes two different parameterized constructors to show overloading.

```cpp
#include <iostream>
#include <string>

// Define a class to represent a Book.
class Book {
public:
    std::string title;
    std::string author;
    int publicationYear;

    // 1. Parameterized Constructor
    // This constructor takes two parameters: a title and an author.
    // It's used to initialize a Book object with a specific title and author.
    Book(std::string t, std::string a) {
        title = t;
        author = a;
        publicationYear = 0; // Set a default value for a member not in the parameters.
        std::cout << "Parameterized constructor (title and author) called." << std::endl;
    }

    // 2. Another Parameterized Constructor (Overloading)
    // This constructor takes three parameters: title, author, and publication year.
    // This demonstrates constructor overloading, where multiple constructors can
    // exist as long as their parameter lists are unique.
    Book(std::string t, std::string a, int year) {
        title = t;
        author = a;
        publicationYear = year;
        std::cout << "Parameterized constructor (all fields) called." << std::endl;
    }

    // Member function to display the book's details.
    void display() {
        std::cout << "Title: " << title << std::endl;
        std::cout << "Author: " << author << std::endl;
        if (publicationYear != 0) {
            std::cout << "Published: " << publicationYear << std::endl;
        }
        std::cout << "------------------------" << std::endl;
    }
};

int main() {
    // Using the first parameterized constructor.
    // The arguments "The Hitchhiker's Guide to the Galaxy" and "Douglas Adams"
    // are passed to the constructor.
    Book book1("The Hitchhiker's Guide to the Galaxy", "Douglas Adams");
    
    // The `display()` function shows the values set by the constructor.
    book1.display();

    // Using the second parameterized constructor (overloaded version).
    // This time, three arguments are provided, so the second constructor is called.
    Book book2("1984", "George Orwell", 1949);

    // `book2` is initialized with all three values.
    book2.display();

    return 0;
}
```






Multiple constructors in C++, a concept known as **constructor overloading**, allow a class to have several constructors with the same name but different parameter lists. This provides flexibility in how an object can be initialized. The compiler determines which constructor to call based on the number and type of arguments passed during object creation.

-----

### Key Details and Principles

  * **Constructor Overloading:** This is a specific form of function overloading applied to constructors. The signature of each constructor (the number and types of its parameters) must be unique.
  * **Flexibility:** It allows you to initialize an object in different ways. For example, a `Person` class could be initialized with just a name, or with a name and age, or with a full set of details.
  * **No Return Type:** Like all constructors, overloaded constructors do not have a return type.
  * **Compiler's Role:** The compiler selects the appropriate constructor to invoke at compile time through a process called **static dispatch** or **overload resolution**. It matches the arguments provided in the object creation statement to the parameter list of the available constructors.

-----

### C++ Code with Detailed Explanation

This example demonstrates a `Box` class with multiple constructors to handle different initialization scenarios. The code and its comments explain how each constructor is defined and used.

```cpp
#include <iostream>

class Box {
public:
    double length;
    double width;
    double height;

    // 1. Default Constructor
    // Called when no arguments are passed. Initializes a default box.
    Box() {
        length = 0.0;
        width = 0.0;
        height = 0.0;
        std::cout << "Default constructor called: Box created with default dimensions (0, 0, 0)." << std::endl;
    }

    // 2. Parameterized Constructor
    // Called with one argument. Creates a cube with equal sides.
    // This allows for a simplified way to create a cube object.
    Box(double side) {
        length = side;
        width = side;
        height = side;
        std::cout << "Parameterized constructor (cube) called: Box created with side " << side << "." << std::endl;
    }

    // 3. Parameterized Constructor (Overloaded)
    // Called with three arguments. Creates a box with specific, different dimensions.
    // This provides the most control over the box's size.
    // The compiler distinguishes this constructor from the others by its three 'double' parameters.
    Box(double l, double w, double h) {
        length = l;
        width = w;
        height = h;
        std::cout << "Parameterized constructor (L, W, H) called: Box created with dimensions ("
                  << l << ", " << w << ", " << h << ")." << std::endl;
    }

    // A simple member function to calculate and display the volume.
    double calculateVolume() {
        return length * width * height;
    }

    // A display function for better output.
    void displayVolume() {
        std::cout << "Volume: " << calculateVolume() << std::endl;
        std::cout << "-----------------------------------" << std::endl;
    }
};

int main() {
    // a. Create an object using the default constructor.
    // The compiler sees no arguments and calls the Box() constructor.
    Box box1;
    box1.displayVolume();

    // b. Create an object using the single-parameter constructor.
    // The compiler sees one 'double' argument and calls the Box(double side) constructor.
    Box box2(10.0);
    box2.displayVolume();

    // c. Create an object using the three-parameter constructor.
    // The compiler sees three 'double' arguments and calls the Box(double l, double w, double h) constructor.
    Box box3(5.0, 8.0, 2.5);
    box3.displayVolume();

    return 0;
}
```

Overloaded constructors in C++ are multiple constructors within the same class that share the same name but have different parameter lists. This is a form of **function overloading** specific to constructors. It allows you to create objects in different ways, providing flexibility for initialization. ðŸ”„

-----

### Key Principles of Overloaded Constructors

  * **Distinct Signatures:** Each overloaded constructor must have a unique signature, which is determined by the number and/or types of its parameters.
  * **Compile-Time Resolution:** The C++ compiler decides which constructor to call based on the arguments provided during object creation. This process is known as **overload resolution**.
  * **No Return Type:** Like all constructors, overloaded constructors do not have a return type.
  * **Relationship with Default Constructor:** If you create any parameterized constructor, the compiler will **not** automatically provide a default constructor. If you still need a default constructor (one that takes no arguments), you must define it explicitly.

-----

### C++ Code with Detailed Explanation

Here's a C++ example using a `Car` class with multiple constructors to demonstrate overloading. The code and comments explain how each constructor is defined and used to initialize objects with different levels of detail.

```cpp
#include <iostream>
#include <string>

// A class to represent a Car.
class Car {
public:
    std::string brand;
    std::string model;
    int year;

    // 1. Default Constructor
    // Takes no arguments. It initializes a "basic" car with default values.
    Car() {
        brand = "Unknown";
        model = "Unknown";
        year = 2023; // A default year.
        std::cout << "Default constructor called: Created an unknown car." << std::endl;
    }

    // 2. Parameterized Constructor (Brand and Model)
    // Takes two string arguments. Used for initializing a car with its brand and model.
    // The year is set to a default value.
    Car(std::string carBrand, std::string carModel) {
        brand = carBrand;
        model = carModel;
        year = 2023; // Default year
        std::cout << "Two-parameter constructor called: Created a " << year << " " << brand << " " << model << std::endl;
    }

    // 3. Parameterized Constructor (Brand, Model, and Year)
    // Takes a brand, model, and year. This is the most detailed constructor.
    // The compiler distinguishes this from the previous one by the third integer parameter.
    Car(std::string carBrand, std::string carModel, int carYear) {
        brand = carBrand;
        model = carModel;
        year = carYear;
        std::cout << "Three-parameter constructor called: Created a " << year << " " << brand << " " << model << std::endl;
    }

    // A member function to display the car's details.
    void displayDetails() {
        std::cout << "Brand: " << brand << ", Model: " << model << ", Year: " << year << std::endl;
        std::cout << "-----------------------------------" << std::endl;
    }
};

int main() {
    // Calling the constructors with different arguments:

    // a. Object created using the default constructor.
    // No arguments are provided, so the `Car()` constructor is used.
    Car car1;
    car1.displayDetails();

    // b. Object created using the two-parameter constructor.
    // Two strings are provided, so `Car(string, string)` is selected.
    Car car2("Toyota", "Camry");
    car2.displayDetails();

    // c. Object created using the three-parameter constructor.
    // Two strings and an integer are provided, so `Car(string, string, int)` is selected.
    Car car3("Ford", "Mustang", 1969);
    car3.displayDetails();

    return 0;
}
```




A constructor with **default arguments** is a parameterized constructor where some or all of the parameters have a default value. This allows you to call the constructor with fewer arguments than it's defined to accept. It's a powerful feature that combines the functionality of a default constructor and a parameterized constructor into a single function. ðŸ—ï¸

-----

### Key Details and Usage

  * **Flexibility:** It provides the flexibility of a parameterized constructor while also allowing for a "default" initialization if no arguments are provided.
  * **Default Values:** You specify default values for parameters in the constructor's declaration. When a call to the constructor omits an argument, the corresponding default value is used.
  * **Order Matters:** Default arguments must be placed at the end of the parameter list. The compiler requires this so it can match the provided arguments from left to right.
  * **Single Constructor:** This approach can replace multiple overloaded constructors, simplifying your code. For example, a single constructor with default arguments can serve the purpose of both a default constructor and several parameterized constructors.

-----

### C++ Code with Detailed Explanation

Here's a C++ example using a `Rectangle` class with a constructor that uses default arguments. The code and comments demonstrate how to define and use this type of constructor for different object creation scenarios.

```cpp
#include <iostream>

class Rectangle {
public:
    double length;
    double width;

    // Constructor with default arguments.
    // Both 'l' and 'w' have default values of 1.0.
    // This single constructor can be called in three ways:
    // 1. With no arguments: length = 1.0, width = 1.0
    // 2. With one argument: length = l_arg, width = 1.0
    // 3. With two arguments: length = l_arg, width = w_arg
    Rectangle(double l = 1.0, double w = 1.0) {
        length = l;
        width = w;
        std::cout << "Constructor called. Rectangle dimensions are: "
                  << length << " x " << width << std::endl;
    }

    // A member function to calculate and display the area.
    double calculateArea() {
        return length * width;
    }

    void displayArea() {
        std::cout << "Area: " << calculateArea() << std::endl;
        std::cout << "-----------------------------------" << std::endl;
    }
};

int main() {
    // a. Object created with NO arguments.
    // The constructor uses the default values (l=1.0, w=1.0).
    Rectangle rect1;
    rect1.displayArea();

    // b. Object created with ONE argument.
    // The constructor uses the provided value for 'l' (5.0) and the default for 'w' (1.0).
    Rectangle rect2(5.0);
    rect2.displayArea();

    // c. Object created with TWO arguments.
    // The constructor uses both provided values (l=8.0, w=4.5).
    Rectangle rect3(8.0, 4.5);
    rect3.displayArea();

    return 0;
}
```




Dynamic initialization of objects is the process of initializing an object at **runtime** using the `new` operator. The value or state of the object is determined by an expression or a function call that executes at the moment the object is created, rather than at compile time. This is particularly useful when the data needed for initialization is not known in advance. ðŸš€

-----

### Key Details and Usage

  * **Runtime Initialization:** The object's initial state is set during program execution, not when the code is compiled. This is in contrast to static or compile-time initialization, where the values are hardcoded.
  * **`new` and `delete` Operators:** Dynamic initialization almost always involves the **`new`** operator, which allocates memory on the heap and calls a constructor to initialize the object. The corresponding memory must be freed later using the **`delete`** operator to avoid memory leaks.
  * **Pointers:** Objects created dynamically are accessed through a pointer. The `new` operator returns a pointer to the newly created object.
  * **Constructors:** The process of dynamic initialization relies heavily on constructors. The `new` operator calls the appropriate constructor (default or parameterized) to set up the object.

-----

### C++ Code with Detailed Explanation

This C++ example demonstrates dynamic initialization of objects using a `Circle` class. The code and its comments show how to create objects with initial values determined at runtime, using user input.

```cpp
#include <iostream>

class Circle {
private:
    double radius;
    double area;

public:
    // A parameterized constructor to initialize the circle.
    Circle(double r) {
        radius = r;
        area = 3.14159 * radius * radius;
        std::cout << "Parameterized constructor called. Circle object initialized with radius: " << radius << std::endl;
    }

    // Member function to display the circle's properties.
    void display() {
        std::cout << "Circle Details:" << std::endl;
        std::cout << "  Radius: " << radius << std::endl;
        std::cout << "  Area: " << area << std::endl;
    }
};

// A function to get user input and create a Circle object.
void createDynamicCircle() {
    double userRadius;
    std::cout << "Please enter a radius for the circle: ";
    std::cin >> userRadius;

    // 1. DYNAMIC INITIALIZATION
    // The 'new' operator allocates memory on the heap for a Circle object.
    // It then calls the parameterized constructor with the user-provided 'userRadius'.
    // The pointer 'myCircle' stores the memory address of the new object.
    Circle* myCircle = new Circle(userRadius);

    // 2. USING THE DYNAMICALLY INITIALIZED OBJECT
    // We use the arrow operator '->' to access the member functions
    // of the object through the pointer.
    myCircle->display();

    // 3. CLEANUP
    // It is crucial to deallocate the memory allocated with 'new'.
    // The 'delete' operator calls the object's destructor and then frees the memory.
    // Forgetting this step leads to a memory leak.
    delete myCircle;
    myCircle = nullptr; // Good practice to set the pointer to nullptr after deletion.

    std::cout << "Memory for the circle object has been freed." << std::endl;
}

int main() {
    std::cout << "--- Demonstration of Dynamic Initialization ---" << std::endl;
    createDynamicCircle();
    return 0;
}
```



A **copy constructor** is a special type of constructor that creates a new object as a copy of an existing object. It's automatically called when you pass an object by value to a function, return an object by value, or explicitly create a new object from an existing one. ðŸ“

-----

### Key Details and Principles

  * **Signature:** A copy constructor takes a single argument: a constant reference to an object of the same class. The format is `ClassName(const ClassName& obj)`. The `const` keyword is crucial to prevent the constructor from modifying the original object, and passing by reference (`&`) avoids creating an infinite loop of copy constructor calls.
  * **Default Copy Constructor:** If you don't define a copy constructor, the C++ compiler provides a default one. This default constructor performs a **shallow copy**, which means it simply copies the values of all data members from the source object to the destination object. This works fine for simple data types but can lead to problems with dynamic memory.
  * **Shallow vs. Deep Copy:**
      * **Shallow Copy:** Copies the member values directly. If a member is a pointer, only the pointer's address is copied, not the data it points to. This can cause issues like a **dangling pointer** or **double deletion** of memory when one of the objects is destroyed.
      * **Deep Copy:** Creates a new copy of the data that the pointer points to. This requires you to define your own copy constructor to handle dynamic memory allocation correctly.

-----

### C++ Code with Detailed Explanation

This C++ example demonstrates the difference between a shallow and a deep copy and how to write a custom copy constructor to handle dynamic memory.

```cpp
#include <iostream>

class SmartArray {
public:
    int* data;
    int size;

    // Parameterized Constructor
    // Dynamically allocates memory for the array.
    SmartArray(int s) {
        size = s;
        data = new int[size];
        std::cout << "Constructor called. Memory allocated." << std::endl;
    }

    // Custom Copy Constructor (Performs a Deep Copy)
    // This is necessary because of the dynamic memory `data`.
    SmartArray(const SmartArray& other) {
        size = other.size;
        // 1. Allocate new memory for the copy. This is the "deep" part.
        data = new int[size];
        
        // 2. Copy the contents of the array, not just the pointer.
        for (int i = 0; i < size; i++) {
            data[i] = other.data[i];
        }
        std::cout << "Copy constructor called. Deep copy performed." << std::endl;
    }

    // Destructor
    // Frees the memory allocated by the constructor.
    ~SmartArray() {
        delete[] data;
        std::cout << "Destructor called. Memory freed." << std::endl;
    }

    // A utility function to set and get a value.
    void setValue(int index, int value) {
        if (index >= 0 && index < size) {
            data[index] = value;
        }
    }

    int getValue(int index) {
        if (index >= 0 && index < size) {
            return data[index];
        }
        return -1;
    }
};

void demonstrateShallowCopyProblem() {
    std::cout << "--- Demonstrating why a custom copy constructor is needed ---" << std::endl;
    
    // Using the default copy constructor (if we had not defined our own).
    // `arr1` creates a new array and points to it.
    SmartArray arr1(3);
    arr1.setValue(0, 10);
    
    // If the compiler-generated copy constructor was used, `arr2`'s `data` pointer
    // would point to the SAME memory location as `arr1`'s `data`.
    SmartArray arr2 = arr1; // This calls our custom copy constructor.
    
    // Let's modify `arr2`. With a deep copy, this only affects `arr2`.
    // With a shallow copy, this would also change `arr1`.
    arr2.setValue(0, 99);

    std::cout << "arr1[0] after modifying arr2: " << arr1.getValue(0) << std::endl;
    std::cout << "arr2[0] after modifying arr2: " << arr2.getValue(0) << std::endl;

    // When `arr1` and `arr2` go out of scope, their destructors are called.
    // If it were a shallow copy, both destructors would try to `delete[]` the
    // SAME block of memory, leading to a program crash (double deletion).
    // With our custom copy constructor (deep copy), each object has its own memory
    // and the destructors work correctly.
} // The destructors for arr2 and arr1 are called here.

int main() {
    demonstrateShallowCopyProblem();
    return 0;
}
```



A **dynamic constructor** isn't a separate type of constructor in C++, but rather the process of calling a constructor using the **`new` operator** to create an object on the **heap** (dynamic memory). The `new` operator allocates memory and then calls the appropriate constructor to initialize the object at runtime. ðŸ—ï¸

-----

### Key Details and Usage

  * **Dynamic Allocation:** The primary purpose of dynamic construction is to allocate an object's memory from the heap, not the stack. This is useful when the object's size or existence is not known until the program runs.
  * **`new` Operator:** The `new` operator is the key to this process. It performs two actions:
    1.  **Memory Allocation:** It allocates the required memory on the heap.
    2.  **Constructor Call:** It calls the class's constructor (default or parameterized) to initialize the newly allocated memory.
  * **Pointers:** The `new` operator returns a **pointer** to the newly created object. You must use this pointer to access the object's members.
  * **Resource Management:** Objects created with `new` must be manually deallocated using the **`delete` operator** to prevent **memory leaks**. `delete` calls the destructor and then frees the memory.

-----

### C++ Code with Detailed Explanation

This C++ example shows how to use `new` to perform dynamic construction with a `Product` class. It demonstrates using both a default and a parameterized constructor in a dynamic context.

```cpp
#include <iostream>
#include <string>

class Product {
public:
    std::string name;
    double price;

    // Default Constructor
    // Called when a Product object is created with `new Product()`.
    Product() {
        name = "Unknown";
        price = 0.0;
        std::cout << "Default constructor called for dynamic object." << std::endl;
    }

    // Parameterized Constructor
    // Called when a Product object is created with `new Product(...)`.
    Product(std::string n, double p) {
        name = n;
        price = p;
        std::cout << "Parameterized constructor called for dynamic object." << std::endl;
    }

    // Destructor
    // Called automatically by `delete` to clean up resources.
    ~Product() {
        std::cout << "Destructor called. Object '" << name << "' is being destroyed." << std::endl;
    }

    // A utility function to display product details.
    void display() {
        std::cout << "Product: " << name << ", Price: $" << price << std::endl;
    }
};

void createProductsDynamically() {
    // 1. DYNAMIC CONSTRUCTION using the DEFAULT constructor
    // The `new` operator allocates memory and calls the `Product()` constructor.
    // `product1` is a pointer to the new object.
    Product* product1 = new Product();
    product1->display();
    std::cout << "-----------------------------------" << std::endl;

    // 2. DYNAMIC CONSTRUCTION using the PARAMETERIZED constructor
    // The `new` operator allocates memory and calls the `Product(string, double)` constructor.
    // `product2` is a pointer to this new object.
    Product* product2 = new Product("Laptop", 1200.50);
    product2->display();
    std::cout << "-----------------------------------" << std::endl;

    // 3. CLEANUP - THE MOST CRUCIAL STEP
    // The `delete` operator is used to deallocate the memory and call the destructor.
    // If we don't do this, the memory will not be freed, causing a memory leak.
    delete product1;
    product1 = nullptr; // Good practice to set the pointer to nullptr after deletion.

    delete product2;
    product2 = nullptr;

    std::cout << "All dynamically allocated memory has been freed." << std::endl;
} // `product1` and `product2` pointers go out of scope, but the memory would leak if we didn't use `delete`.

int main() {
    createProductsDynamically();
    return 0;
}
```

